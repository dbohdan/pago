#! /usr/bin/env tclsh
#
# patcl - a simple password manager.
#
# This program is a fork of pash translated to Tcl and switched from GPG
# to age public-key encryption.
# It requires a *nix operating system with age installed.
# See https://github.com/FiloSottile/age.
# Original repository: https://github.com/dylanaraps/pash (archived).
#
# ==============================================================================
#
# The MIT License (MIT)
#
# Copyright (c) 2016-2019 Dylan Araps
# Copyright (c) 2024 D. Bohdan
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# ==============================================================================

package require Tcl 8.6 9
# No Tcllib. Don't add it as a dependency.

namespace eval ::patcl {}

proc ::patcl::config args {
    variable config

    switch -- [llength $args] {
        1 {
            lassign $args key
            return [dict get $config $key]
        }

        2 {
            lassign $args key value
            dict set config $key $value
        }

        default {
            error {wrong # args: should be "config key ?value?"}
        }
    }
}

proc ::patcl::env {varName default} {
    set value $default
    set env [array get ::env]
    if {[dict exists $env $varName]} {
        set value [dict get $env $varName]
    }

    return $value
}

proc ::patcl::configure {} {
    config home [expr {
        [string match 8.* [info patchlevel]]
        ? [file normalize ~]
        : [file home]
    }]
    config data_home [env \
        XDG_DATA_HOME \
        [file join [config home] .local share] \
    ]

    config dir [env PATCL_DIR [file join [config data_home] patcl]]
    config identities [file join [config dir] identities]
    config store [file join [config dir] store]
    config recipients [file join [config store] .age-recipients]

    config clip [env PATCL_CLIP {xclip -in -selection clip}]
    config length [env PATCL_LENGTH 20]
    config pattern [env PATCL_PATTERN _A-Z-a-z-0-9]
    config timeout [env PATCL_TIMEOUT 30]
}

namespace eval ::patcl {
    variable VERSION 0.2.0
    variable config {}
}

proc ::patcl::generate {} {
    # Generate a password by reading '/dev/urandom' and translating the
    # random bytes into a configurable character set.
    #
    # Regarding usage of '/dev/urandom' instead of '/dev/random'.
    # See: https://www.2uo.de/myths-about-urandom
    set pass {}

    try {
        set ch [open /dev/urandom rb]
        while {[string length $pass] < [config length]} {
            set c [read $ch 1]

            try {
                if {![string match \[[config pattern]\] $c]} {
                    continue
                }
            } on error _ {
                die {Invalid password character pattern}
            }

            append pass $c
        }
    } on error e {
        die $e
    } finally {
        catch {
            close $ch
        }
    }

    return $pass
}

proc ::patcl::decrypt_ids {} {
    try {
        exec age --decrypt [config identities] <@ stdin 2>@ stderr
   } on error e {
       die $e
    }
}

proc ::patcl::add name {
    if {[yn {Generate a password?}]} {
        set pass [generate]
    } else {
        # [sread] is a simple wrapper function around [gets]
        # to prevent user input from being printed to the terminal.
        set pass [sread {Enter password}]
        set pass2 [sread {Enter password (again)}]

        if {$pass ne $pass2} {
            die {Passwords do not match}
        }
    }

    if {$pass eq {}} {
        die {Empty password}
    }

    # Use 'age' to store the password in an encrypted file.
    try {
        exec age \
            --encrypt \
            --output $name.age \
            --recipients-file [config recipients] \
            << $pass \
            >@ stdout \
            2>@ stderr \
            ;
    } on error e {
        die $e
    }

    puts "Saved '$name' to the store."
}

proc ::patcl::del name {
    if {![yn "Delete pass file '$name'?"]} return

    file delete $name.age

    # Remove empty parent directories of a password
    # entry. It's fine if this fails as it means that
    # another entry also lives in the same directory.
    catch {
        file delete [file dirname $name]
    }
}

namespace eval ::fifo {}

proc ::fifo::mkfifo {{template {}}} {
    close [file tempfile path $template]
    file delete $path

    exec mkfifo -m 0600 $path

    return $path
}

proc ::fifo::with_fifos args {
    set template {}
    if {{-template} eq [lindex $args 0]} {
        set args [lassign $args _ template]
    }

    if {[llength $args] == 0} {
        error "wrong # args: should be\
            \"with-fifos ?-template template? ?varName ...? script\""
    }

    set varNames [lrange $args 0 end-1]
    set script [lindex $args end]

    try {
        foreach varName $varNames {
            upvar 1 $varName v
            set v [mkfifo $template]
        }

        uplevel 1 $script
    } finally {
        foreach varName $varNames {
            upvar 1 $varName v
            file delete $v
        }
    }
}

proc ::patcl::show name {
    set ids [decrypt_ids]

    try {
        ::fifo::with_fifos fifo {
            exec age \
                --decrypt \
                --identity $fifo $name.age \
                >@ stdout \
                2>@ stderr \
                & \
                ;

            set ch [open $fifo w]
            puts $ch $ids
        }
    } on error e {
        die $e
    } finally {
        catch {
            close $ch
        }
    }
}

proc ::patcl::copy name {
    set timeout [config timeout]
    if {[string tolower $timeout] eq {off}} {
        set timeout 0
    }

    # Validate the timeout. No infinities or NaN.
    if {
        ![string is double -strict $timeout]
        || $timeout == -inf
        || $timeout == inf
        || $timeout != $timeout
    } {
        die {Timeout isn't a number}
    }

    set ids [decrypt_ids]

    if {$timeout > 0} {
        puts "Clearing clipboard in $timeout seconds."
    }

    try {
        ::fifo::with_fifos fifo {
            exec age \
                --decrypt \
                --identity $fifo \
                $name.age \
            | {*}[config clip] \
                >@ stdout \
                2>@ stderr \
                & \
                ;

            set ch [open $fifo w]
            puts $ch $ids
        }
    } on error e {
        die $e
    } finally {
        catch {
            close $ch
        }
    }

    # Wait for the password timeout and clear the clipboard.
    if {$timeout > 0} {
        after [expr {int($timeout * 1000)}]
        exec {*}[config clip] << {} >@ stdout 2>@ stderr
    }
}

proc ::patcl::list_all {} {
    foreach f [split [exec find . -type f -name *.age] \n] {
        puts [file rootname $f]
    }
}

proc ::patcl::tree {} {
    try {
        exec tree
    } on error _ {
        die {'tree' command not found}
    }

    puts [string map {.age {}} [exec tree --noreport]]
}

proc ::patcl::yn prompt {
    puts -nonewline "$prompt \[y/n\]: "

    # Enable raw input to allow for a single byte to be read from
    # stdin without needing to wait for the user to press Return.
    exec stty -icanon >@ stdout 2>@ stderr

    set answer [read stdin 1]

    # Disable raw input, leaving the terminal how we *should*
    # have found it.
    exec stty icanon >@ stdout 2>@ stderr

    puts {}

    # Handle the answer here directly, enabling this function's
    # return status to be used in place of checking for '[yY]'
    # throughout this program.
    return [expr {$answer in {y Y}}]
}

proc ::patcl::sread prompt {
    puts -nonewline "$prompt: "

    # Disable terminal printing while the user inputs their
    # password.
    exec stty -echo >@ stdout 2>@ stderr
    set input [gets stdin]
    exec stty echo >@ stdout 2>@ stderr

    puts {}

    return $input
}

proc ::patcl::die message {
    puts stderr "error: $message"
    exit 1
}

proc ::patcl::usage exit_code {
    variable VERSION

    set clip [config clip]
    set dir [string map [list [config home] ~] [config dir]]
    set length [config length]
    set pattern [config pattern]
    set timeout [config timeout]

    puts "patcl $VERSION - simple password manager."
    puts [subst -nobackslashes -nocommands {
=> [a]dd  [name] - Create a new password entry.
=> [c]opy [name] - Copy entry to the clipboard.
=> [d]el  [name] - Delete a password entry.
=> [g]enerate    - Generate a password.
=> [l]ist        - List all entries.
=> [s]how [name] - Show password for an entry.
=> [t]ree        - List all entries in a tree.

Using a key pair:  export PATCL_KEYID=XXXXXXXX
Password length:   export PATCL_LENGTH=$length
Password pattern:  export PATCL_PATTERN=$pattern
Store location:    export PATCL_DIR=$dir
Clipboard tool:    export PATCL_CLIP='$clip'
Clipboard timeout: export PATCL_TIMEOUT=$timeout ('off' to disable)}]

    exit $exit_code
}

proc ::patcl::main argv {
    configure

    if {[llength $argv] == 0} {
        usage 0
    }

    try {
        file mkdir [config store]
    } on error _ {
        die {Couldn't create password store directory}
    }

    try {
        cd [config store]
    } on error _ {
        die {Can't access password directory}
    }

    set command [lindex $argv 0]
    set name {}
    if {[llength $argv] >= 2} {
        set name [lindex $argv 1]
    }

    if {[string match {[acds]*} $command] && $name eq {}} {
        die {Missing [name] argument}
    }

    if {[string match {[cds]*} $command] && ![file exists $name.age]} {
        die "Pass file '$name' doesn't exist"
    }

    if {[string match a* $command] && [file exists $name.age]} {
        die "Pass file '$name' already exists"
    }

    if {[string match *../* $name]} {
        die {Category went out of bounds}
    }

    if {[string match /* $name]} {
        die {Category can't start with '/'}
    }

    if {[string match */* $name]} {
        set dir [file dirname $name]
        try {
            file mkdir $dir
        } on error _ {
            die "Couldn't create category '$name'"
        }
    }

    try {
        switch -glob -- $command {
            a -
            add { add $name }

            c -
            copy { copy $name }

            d -
            del { del $name }

            g -
            gen -
            generate { puts [generate] }

            h -
            help { usage 0 }

            s -
            show { show $name }

            l -
            list { list_all }

            t -
            tree { tree }

            default { usage 2 }
        }
    } finally {
        # Ensure that we leave the terminal in a usable
        # state on exit or Ctrl+C.
        exec stty echo icanon >@ stdout 2>@ stderr
    }
}

# If this is the main script...
if {[info exists argv0] && ([file tail [info script]] eq [file tail $argv0])} {
    ::patcl::main $argv
}
